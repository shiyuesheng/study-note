# JVM学习-内存结构-运行时数据区

## JVM运行时数据区

<img src="/Users/shiyuesheng/Desktop/java技术笔记/Jvm虚拟机/图片/JVM运行时数据区.jpg" alt="JVM运行时数据区" style="zoom:40%;" />

*简要描述：*

### **程序计数器**

- 记录正在执行的虚拟机字节码指令地址
- 字节码解释器通过改变计数器，选取下一条字节码指令，是程序流程的控制器
- 线程上下文切换时，记录、恢复现场
- 线程私有，生命周期与线程相同
- 没有规定OutOfMemoryError

### **Java虚拟机栈**

- 线程运行的内存模型，每调用一个方法，压入一个栈帧
- 栈帧存放局部变量表、操作数栈、动态链接、方法出口信息
- 栈帧大小编译期确定
- 线程上下文切换时，记录、恢复现场
- 线程私有，生命周期与线程相同
- 线程私有，所以线程安全
- StackOverflowError 、OutOfMemoryError
- 方法内的局部变量，如果是原生数据类型，存放的栈帧上；如果是对象引用，则栈帧上存放的是引用地址，而对象本身存放在堆上。

### **本地方法栈**  略～

### **Java堆**

- 几乎所有的对象都存储在堆中
- 虚拟机启动时创建
- 线程共享，所以存在对象内存分配的同步问题，TLAB 线程内存分配缓冲优化
- 垃圾回收主要场所
- 无法分配新的内存，且无法扩展时 OutOfMemoryError

### **方法区**

- 用于存储虚拟机加载的类型信息、常量、静态常量、即时编译器编译后的代码缓存等数据
- 元数据空间实现
- 线程共享
- 运行时常量池、CCS 压缩指针

### **直接内存**

- 堆外内存，这个第方一直心存疑惑，这块内存到底是在用户态、还是在内核态？

- 线上进行JVM内存参数配置的时候，要考虑这部分的内存的使用大小，避免出现配置的虚拟机内存接近或者超过物理内存，尤其是使用netty io框架的时候。一般这块内存可以保持跟堆内存大小一致。

  *上一张JVM内存全景图，有些花花绿绿*

  <img src="/Users/shiyuesheng/Desktop/java技术笔记/Jvm虚拟机/图片/JVM内存全景图.jpg" alt="JVM内存全景图" style="zoom:80%;" />

## 程序计数器 (Program Counter Register)

​	程序计数器(Program Counter Register)是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在Java虚拟机的概念模型里[1]，**字节码解释器工作时就是通过改变这个计数器 的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处 理、线程恢复等基础功能都需要依赖这个计数器来完成。**

​	由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一 个确定的时刻，一个处理器(对于多核处理器来说是一个内核)都只会执行一条线程中的指令。**因 此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程 之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存**。

​	如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地 址;如果正在执行的是本地(N at ive)方法，这个计数器值则应为空(U ndefined)。**此内存区域是唯 一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。**

## Java虚拟机栈 (Java Virtual Machine Stack)

​	Java虚拟机栈(Java Virtual Machine Stack)是**线程私有**的，它的**生命周期与线程相同**。虚拟机栈描述的是Java方法执行的线程内存模型：**每个方法被执行的时候，Java虚拟机栈都会同步创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息**。**每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。**

​	局部变量表存放了编译期可知的各种Java虚拟机**基本类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference类型）、和**returenAddress**（指向一条字节码指令）类型。

​	这些数据类型在局部变量表中的存储空间以局部变量槽（Slot）来表示，long、double类型数据占用两个槽位，其余数据类型占用1个。**局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间时完全确定的**。

​	《Java虚拟机规范》对这个内存区域规定了两类异常情况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutofMemoryError异常。

​	HotSpot虚拟机的栈容量是不可以动态扩容的，所以在HotSpot虚拟机上是不会由于虚拟机栈无法扩展而导致OutOfMemoryError异常。但是如果在申请栈空间时，因为内存不足而申请失败，还是会抛出OutOfMemoryError异常。

## 本地方法栈(Native Method Stacks)

​	本地方法栈(Native Method Stacks)与虚拟机栈发挥的作用相似，区别在于虚拟机栈为虚拟机执行Java方法（字节码）服务，而本地方法栈则是为虚拟机使用的本地（Native）方法服务。

​	**HosSpot虚拟机已经把虚拟机栈、本地方法栈合二为一。**

## Java堆(Java Heap)

​	Java堆(Java Heap)是被所有线程共享的一块内存区域，在虚拟机启动时创建。所有的对象实例以及数组都应该在这里分配内存。以G1垃圾收集器为界限，Java虚拟机的堆内存布局，可以使用新生代，老年代，永久代，Eden，Survivor等来描述。

​	内存分配缓冲区TLAB(Thread Local Allocation Buffer)，这个是线程私有的，目的是因为虚拟机分配对象的内存时要保证内存资源的安全，多线程的情况下必然会有同步的问题，线程私有的内存分配缓冲区可以绕过这个同步问题，提升对象分配时的效率。线程的生命周期中所使用的内存大小，可以作为TLAB的经验参考值。当超出TLAB大小限制时，还是会存在对象内存分配的同步问题。

​	内存分配参数 -Xmx:最大内存， -Xms:最小内存，若果Java堆中没有内存可以分配，并且无法再扩展了，抛出OutOfMemoryError异常。

## 方法区(Method Area)

​	方法区(Method Area)是线程共享区域，用于存储虚拟机加载的类型信息、常量、静态常量、即时编译器编译后的代码缓存等数据。《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做“非堆”(Non-Heap)，目的是与Java堆区分开来。

​	永久代(Permanent)，HotSpot以前使用永久代来实现方法区，目的是为了不用为方法区实现垃圾收集器，这样可以向管理堆内存一样管理方法区。永久代空间有默认上限，-XX:MaxPermSize 可以设置上限。这块区域会遇到内存溢出问题。

​	JDK8彻底废弃了永久代，方法区在本地内存(Native Memory)实现元空间(Meta-space)。

​	方法区的内存回收目标主要是针对常量池、对类型的卸载。但是回收效果很难“令人满意”。

### 运行时常量池(Runtime Constant Pool)

​	运行时常量池(Runtime Constant Pool)是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表(Constant Pool Table)，用于存放编译期生成的各种字面量与符号引用，这部分内容再类加载后存放到方法区的运行时常量池中。

​	运行时常量池跟Class文件常量池表是不同的概念。

- Class的格式有严格的规定，当然常量池表也是如此。

- 运行时常量池具有动态性，并不是只有Class文件常量池表的数据能够进入运行时常量池，运行期间也可以将新的常量放入其中。面试中令人头疼的 String类的intern()方法。
- 当运行时常量池无法申请到内存时，抛出OutOfMemoryError异常。

### CCS压缩指针  略～

## 直接内存(Direct Memory)

​	直接内存(Direct Memory)并不是虚拟机运行时数据去的一部分。也不是《Java虚拟机规范》中定义的内存区域。这是这块区域的使用也会导致OutOfMemoryError异常。

​	JDK1.4加入了NIO，引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样在一些场景中能够显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。

​	**问题来了，直接内存是怎么回收的呢？DirectByteBuffer与虚幻引用是如何配合的呢？**

​	本机直接内存的分配不会受到Java堆大小的限制，但是既然是内存，还是会受到本机总内存大小的限制，一般服务器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩容时出现OutOfMemoryError异常。



> 参考资料：
>
> 1. 《深入理解Java虚拟机（第三版）》-周志明


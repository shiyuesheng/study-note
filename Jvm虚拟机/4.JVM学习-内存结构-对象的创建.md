# JVM学习-内存结构-对象的创建

> 当Java虚拟机遇到一条字节码new指令时（注意这是new指令，字节码指令，不是Java语言的语法new关键字），首先去检查这个指令的参数是否在运行时常量池中定位到一个类的符号应用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，那么必须先执行相应的类加载过程（见后面的类加载机制）。

## 对象的内存分配

​	类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后完全确定（见后面的对象的内存布局）。内存分配的两种方式：

- **指针碰撞：**假如Java堆内存时绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界的指示器，那么分配内存仅仅是把指针向空闲的方向挪动一块与对象大小相等的距离。

- **空闲列表：**假如Java堆内存并不规整，已经使用的跟未使用的空间交错（内存碎片化），虚拟机维护一个列表，记录那些内存是可以使用的，内存分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。

  选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整由使用的垃圾收集器是否带有空间压缩整理（Compact）的能力决定。因此，当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法时指针碰撞，简单高效；而使用CMS这种基于清除（Sweep）算法的收集器时，理论上采用较为复杂的空闲列表来分配内存。

## 内存分配的安全问题

​	对象的创建在虚拟机中时非常频繁的行为，并发情况下会存在线程安全问题。

- **同步处理：**分配内存空间的动作进行同步处理，虚拟机采用的是CAS配上失败重试的方式保证更新操作的原子性

- **分配缓冲：**分配内存空间的动作按照线程划分在不同的空间之中进行，每个线程在Java堆中预先分配一小块内存（本地线程分配缓冲 TLAB），这样线程运行中创建对象，分配内存就不会遇到线程安全问题，只有本地缓冲区用完，分配新的缓冲区时才需要同步锁定。

  虚拟机是否使用TLAB，可以通过 -XX:+/-UseTLAB 参数设定。

## 对象的初始设置

- 对象头，哈希码、对象的GC分代年龄、元数据信息、是否使用偏向锁
- 成员变量，设置为初始值
- 对齐填充

## 对象的初始化

​	执行Class文件中的<init>()方法，按照程序猿的意愿初始化对象。一般关键字new对象，编译后会生成两个字节码指令 new、invokespecial，new指令对应的就是上面提到的过程，Jvm层面的对象创建；invokespecial <init>()对应的就是调用对象的构造器，执行程序猿层面的对象初始化。

> 参考资料：
>
> 1. 《深入理解Java虚拟机（第三版）》-周志明
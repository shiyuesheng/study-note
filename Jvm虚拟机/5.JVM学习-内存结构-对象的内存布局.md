# JVM学习-内存结构-对象的内存布局

> 在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）、对齐填充（Padding）

## 对象头

​	对象头包含两部分数据，Mark Word、类型指针。

- **Mark Word** 存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳，这部分的数据长度在32位和64位虚拟机（未开启压缩指针）中分别为32（**4个字节**）个比特和64（**8个字节**）个比特。

  Mark Word是一个动态的数据结构，以便在极小的空间存储尽量多的数据，根据对象的状态复用自己的存储空间。

  例如在32位的HotSpot虚拟机中，对象未被锁定的状态下，25比特存储对象哈希码，4比特用于存储对象的分代年龄，2比特用于存储锁标志位，1比特固定位0

|               存储内容               | 标志位 |    状态    |
| :----------------------------------: | :----: | :--------: |
|       对象哈希码、对象分代年龄       |   01   |   未锁定   |
|           指向锁记录的指针           |   00   | 轻量级锁定 |
|          指向重量级锁的指针          |   10   | 重量级锁定 |
|          空，不需要记录信息          |   11   |   GC标记   |
| 偏向线程ID、偏向时间戳、对象分代年龄 |   01   |   可偏向   |

> *这里有好玩的事情：*
>
> 1. *对象分代年龄占用4个比特，转10进制能表示0～15，这就是对象从新生代晋升老年代的年龄最高限制的原因吗？*
> 2. *对象处于未锁定、可偏向的时候有分代年龄，但是其他状态没有分代年龄数据，是不是说明对于那几个状态的对象来说分代年龄已经没有意义了呢？分代年龄是干嘛的，主要是为了控制从年轻代晋升老年代的速度。*

- **类型指针** 指向类型元数据的指针，但并不是所有的虚拟机实现都必须在对象上保留类型指针（见对象的访问定位）

​	如果对象是一个Java数组，对象头中还必须有一块用于记录数组长度的数据，因为普通的Java对象可以通过元数据信息推断对象实例的大小，数组的话则必须通过初始化的大小才能确定实例数据的长度。

## 实例数据

​	没啥好说的，原始类型数据直接存储，引用类型的存储对象指针。

## 对齐填充

​	这并不是必然存在的，也没有特别的含义，仅仅起着占位符的作用。由于HosSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍。

​	对象的大小必须是8字节的整数倍。对象头已经被精心设计成了8字节的整数倍（1倍或者2倍），如果实例数据部分没有对齐的话，就需要对齐填充补全。

> 这里有好玩的事情：
>
> 1、一个对象具有100个属性，和100个对象每个具有1个属性，哪个占用的空间更大？
>
> 显然是100个对象占用空间更大，多出了99个对象的运行时数据，这些数据都是除去有效存储（实例数据）的而外开销，若果加上对齐填充，那浪费的空间将更多。
>
> 2、Integer 比 int多了多少额外空间？
>
> 假设是32位虚拟机，Integer对象头占用了8字节，实例数据4字节，需要对齐填充4字节，总共16字节。
>
> int原始数据类型是4字节，Integer额外多出了3倍的空间占用
>
> 
>
> 当然，正常的业务开发不需要抠这部分的资源浪费情况，一切以业务迭代为重点；但是如果要写一个开源的框架，需要把性能、资源利用到极致，这部分的开销就需要去考虑了。
>
> 
>
> 参考资料：
>
> 1. 《深入理解Java虚拟机（第三版）》-周志明














如果请求量变得特别大，那就是要发财了，对吧？

看具体业务，如果太大也没什么必要，比如大于100万，可能就有100万个对象阻塞在内存里回收不掉。 先凭感觉设置，比如 1000，2000都会比较合理， 如果还不够，那就可以配合对应的拒绝策略来辅助。





线程大小的设置，如果系统里有RPC线程池等其他线程池，可能这些中间件的线程池已经达到了N或者2N，那么自己的业务线程池数量还是按照CPU密集型为N，IO密集型为2*N来设置吗？

比如Tomcat，4核心的CPU，带200-300个连接问题不大，那就是300个线程了。 我们自己维护的线程池，大部分时候有2*N也就差不多了，再多就抢资源，还不如直接在调用线程上执行呢。





大厂里面有使用无界队列的场景么，看书说无界队列的设计，主要可以使请求慢慢堆，相对平滑，不会直接就拒绝

很多请求量的队列直接用MQ，因为JVM内存扛不住太多对象。



锁的目的是为了排队或者限制资源访问。 锁的另一个作用是强刷内存。 根据hapens-before规则，你得到锁的时候「看见标志位改变」，之前临界区内的操作已经全部刷到内存了。



ReadWriteLock管理一组锁，一个是只读的锁，一个是写锁。读锁可以在没有写锁的时候被多个线程同时持有，写锁是独占的。
所有读写锁的实现必须确保写操作对读操作的内存影响。换句话说，一个获得了读锁的线程必须能看到前一个释放的写锁所更新的内容。
读写锁比互斥锁允许对于共享数据更大程度的并发。每次只能有一个写线程，但是同时可以有多个线程并发地读数据。ReadWriteLock适用于读多写少的并发情况。



请教大家一个问题：我有一张200万数据的表，ID无序，我要更新一列的数据，如何用多线程最短时间内做完？

没有索引的话，你就再建一张表，加好索引，数据迁移完毕，直接切换表名，更加合理。



简单问题，知道问题在哪儿，有现成的解决路径

两难问题，选择问题，选择了一个，就得抛弃另一个

棘手问题，大家都知道有问题，但不知道问题在哪里，该如何解决

问题解决思路就是把难的问题优化成多个简单问题去逐步解决
# 数组中只出现一次的数

> - 整数数组中有一个数只出现过一次，其他的数出现过偶数次，找出这个数
> - 整数数组中有两个数只出现过一次，其他的数出现过偶数次，找出这两个数
> - 限制：时间复杂度O(n)，空间复杂度O(1)

## 异或运算符(^)

> 两个位相同为0，相异为1
> 也可以理解为不会进位的位相加 0+0=0,0+1=1,1+1=0

如果相同的两个数做异或操作结果将为0
比如数字  6 ^ 6
		 0 1 1 0  -> 6的低4位
 		0 1 1 0  -> 6的低4位
 		0 0 0 0  -> 结果为0
 		
那如果是一堆重复的数据呢？7^2^9^2^7^9
		 0 1 1 1  -> 7的低4位
 		0 0 1 0  -> 2的低4位
 		1 0 0 1  -> 9的低4位
 		0 0 1 0  -> 2的低4位
 		0 1 1 1  -> 7的低4位
 		1 0 0 1  -> 9的低4位
 		0 0 0 0  -> 结果为0 （可以自己算一下）
我们可以抛开这些数据的顺序，只关注其中的某一位
对于重复存在的数组，每一位的 1 肯定是偶数个，最终的相加结果肯定是0，是不是很像消消乐～ 

我们再往里面插入一个单独的数字 7^2^9^2^3^7^9
		 0 1 1 1  -> 7的低4位
 		0 0 1 0  -> 2的低4位
 		1 0 0 1  -> 9的低4位
 		0 0 1 0  -> 2的低4位
 		0 0 1 1  -> 3的低4位
 		0 1 1 1  -> 7的低4位
 		1 0 0 1  -> 9的低4位
 		0 0 1 1  -> 结果为3 （可以自己算一下）
根据上面的逻辑，只要把每一位的对应的那一列的 1 全部成对的消除就好，剩下的没有消除的 1 落在结果上，最终剩下的就是没有配对消除的3

到这里就能解决数组中只出现一次的一个数 问题了

## 与运算符(&)

>两个位都为1时，结果才为1

## 负数运算符(-)
拿数字6来举例，-6的二进制长什么样子呢？

​		0 1 1 0 -> 6的二进制原码
​		1 0 0 1 -> 6的二进制反码，高位全部反转为1，这里不做展示
​		1 0 1 0 -> 6的二进制补码 就是上面的反码低位加 1
这个 1....(高位) 1 0 1 0 就是 -6 的二进制
怎么还原呢？就是把上面的顺序反着来一遍就行了，转成十进制后前面加个负号
​		1 0 1 0 <- -6的二进制原码
​		1 0 0 1 <- 减1
​		0 1 1 0 <- 反码，结果是 6,加个负号 -6

## n & (-n) 结果是什么呢？有什么意义

> n的二进制中1的最低位

​		0 1 1 0 -> 6的二进制
​		1 0 1 0 -> -6的二进制
​		0 0 1 0 -> 与运算结果 2
结果为2，有什么含义呢？其中一种可以表示为 n 二进制中1的最低（最后面的那个1）
6的话就是 1 0 （二进制）-> 2 (十进制)

为什么这么算得到的就是二进制中1最低位呢？
假设某个数 n 二进制表示为 ？？？？1 0 ... 0  （中间的那个 1 表示数n二进制中1的最低位）
		 ？ ？ ？ ？ 1  0 ... 0 -> n的二进制
		-？-？-？-？ 0  1 ... 1 -> n的反码
		-？-？-？-？ 1  0 ... 0 -> +1，-n
发现了没有，n 和 -n 中 1的最低位之前的数都是相反的，之后的数都是0，
只有1的最低位大家都是1，那 n & （-n）的结果就是：
		 0 0 0 0 1  0 ... 0 -> 数字n二进制中1的最低位

## 一个数

````````````````java

	public static int oneNum(int[] nums) {
        int result = 0;
        //异或累加，相同的消消乐剩下的就是孤独的那一个
        for (int num : nums) {
            result ^= num;
        }
        return result;
	}

	public static void main(String[] args) {
        int[] oneNums = new int[]{1, 2, 3, 5, 3, 2, 1};
        int oneNumsResult = OneTimesNum.oneNum(oneNums);
        System.out.println("只出现一次的一个数：" + oneNumsResult);
	}

````````````````

## 两个数

解题思路：若果按照上面一个数的方式计算，消消乐到最后剩下的就是两个孤独数字 A、B的异或值， A^B = C，那根据C是没办法解析还原出A、B的。

​	能不能借助上一题的思路呢？能否把A、B拆到两个数组中A[]、B[]，而且其他的数也是成对的分到两个数组中A[]、B[],这样就拆分成了2个上一题的解题模型，结果也就显而易见了。

**第一步，怎么把相同的数据拆到相同的数组中？**

​	我们先锁定二进制中的某一位置 index，相同的数字的二进制在index位置上面肯定是相同的，我们可以把index的值是1的分为一组，值是0的分为一组。OK这个index可以随便定，相同的肯定会被分在一起。

**第二步，怎么把A、B拆到不同的数组中？**

A、B不相同，那代表着异或之后无法消除为0，

C的二进制上面肯定存在某一位（或者多位）的值是 1，（异或：两个位相同为0，相异为1），说明在这一位上，A、B是不同的，一个为1、一个为0。

这些异或之后是1的所有位置，我们都可以用来区分A、B的不同，为了方便可以取第一个不同的位置、最后一个不同的位置。

最后一个不同的位置上面提到过，就是 C & (-C) = D，二进制中1的最低位。

那第一步中也可以用D这个位置，随便的嘛～

假设D位置上 A是1，B是0

1、把D位置上是1的全部分到A[]，其中包含了一堆成对的 + A；

2、把D位置上是0的全部分到B[]，其中包含了一堆成对的 + B；

然后使用第一题的解题模型就能找到 A、B了。


````````````````java
	public static int[] twoNums(int[] nums) {

        //得到异或结果，即为不相同两个数的异或结果sum
        int sum = 0;
        for (int num : nums) {
            sum ^= num;
        }

        //得到sum的二进制的1的最低位
        int flag = (-sum) & sum;

        //结果集
        int result[] = new int[2];

        //分成两个组进行异或，每组异或后的结果就是不相同两个数的其中之一
        for (int num : nums) {
        	//flag二进制中只有对应的那个位置上是1，其他位都是0
        	//其他值跟flag做与运算（两个位都为1时，结果才为1）的结果只能是1、或者flag
            if ((flag & num) == 0) {
                result[0] ^= num;
            } else {
                result[1] ^= num;
            }
        }

        return result;
    }

````````````````
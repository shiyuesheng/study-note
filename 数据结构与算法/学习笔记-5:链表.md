



如何用链表来实现 LRU 缓存淘汰策略呢





常见的策略有三种：

先进先出策略 FIFO（First In，First Out）这个很好理解

最少使用策略 LFU（Least Frequently Used）侧重点在使用次数，并不关心是最近访问，还是很久之前的访问

最近最少使用策略 LRU（Least Recently Used）侧重点在时间，最近是否使用过，最终淘汰掉的是陈旧的没有被访问过的数据



节点、前驱指针、后继指针

头结点 用来记录链表的基地址

尾节点 指向一个空地址 NULL





递归：又有了新的理解，像是一个阶段的调用过程，在这个过程有三个点：

1. 承接了上一阶段传入的参数

2. 保留当前阶段的现场，数据快照

3. 继续向下调用、或者执行调用过程的能力，

   就像是一个箭头，我这边处理好了，剩下的交给你了兄弟，等你处理完了我就能向上交差了

数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。

数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区别。

如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是 Java 语言，就有可能会导致频繁的 GC





双指针、向前递归（得需要双指针），向后递归（当前指针），哈希外部存储，栈外部存储，队列外部存储




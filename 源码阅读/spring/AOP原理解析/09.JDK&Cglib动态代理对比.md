# JDK&Cglib动态代理对比

## JDK


1. **基本原理**------Java动态代理只能够对接口进行代理，不能对普通的类进行代理（因为Java动态代理生成的代理类的父类为Proxy，Java类继承机制不允许多重继承）；CGLIB能够代理普通类。
2. **生成过程**------Java动态代理使内置了生成代理类的代码模板，生成逻辑较简单，生成的代理类结构、体量较小，在生成类过程中比较高效。
3. **调用过程**------代理方法最终是通过传统的Java反射，Method.invoke执行的，执行逻辑较为复杂，在执行效率上进行了优化，但同时因为优化造成了一定的风险。

## Cglib

1. **基本原理**------cglib可以为普通类、接口类创建代理。普通类代理是通过继承来实现的。相当于给需要被代理的类创建了一个子类，然后会重写父类中的方法，来进行增强。继承的特性大家应该都知道，遵循Java基本语法，会有如下限制：
   - final修饰的类是不能被继承的，
   - final修饰的方法不能被重写，
   - static修饰的方法也不能被重写，
   - private修饰的方法也不能被子类重写。
2. **生成过程-**-----cglib通过ASM字节码工具生成代理子类，生成逻辑复杂，生成的代理类结构、体量较大。FastClass机制会同时为目标类，代理类生成对应的FastClass子类。所以生成过程相对更加繁琐，效率更低，占用更多的方法区内存资源。当然内部过了优化，比如缓存生成的class，防止多次生成浪费时间成本。
3. **调用过程**------代理方法最终是通过FastClass快速索引机制进行调用，就相当于我们平常写的方法调用，这无疑是非常高效的。

Method运行也做了优化，也有类似FastClass这样的硬编码直接调用，但内部逻辑存在一定的风险，想了解更多看我之前的文章


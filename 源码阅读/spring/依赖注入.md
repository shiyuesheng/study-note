## 注入模式

- **手动模式** - 配置或者编程的方式，提前安排注入规则

  - XML 资源配置元信息
  - Java 注解配置元信息 @Autowired @Resource
  - API 配置元信息

- **自动模式** - 实现方提供依赖自动关联的方式，按照內建的注入规则

  - Autowiring(自动绑定) 主要是 xml配置中的autowire，@Bean中的autowire属性（已标注Deprecated），官方不建议使用，默认关闭。

## 依赖注入类型：

| 依赖注入类型 | 配置元数据举例                                   |
| :------------ | :------------------------------------------------ |
| Setter 方法  | <proeprty name="user" ref="userBean"/>           |
| 构造器       | <constructor-arg name="user" ref="userBean" />   |
| 字段         | @Autowired User user;                            |
| 方法         | @Autowired public void user(User user) { ... }   |
| 接口回调     | class MyBean implements BeanFactoryAware { ... } |

## 自动绑定(Autowiring)模式

• Autowiringmodes

| 模式        | 说明                                                         |
| :----------- | :----------------------------------------------------------- |
| no          | 默认值，未激活 Autowiring，需要手动指定依赖注入对象。        |
| byName      | 根据被注入属性的名称作为 Bean 名称进行依赖查找，并将对象设置到该 属性。 |
| byType      | 根据被注入属性的类型作为依赖类型进行查找，并将对象设置到该属性。 |
| constructor | 特殊 byType 类型，用于构造器参数。                           |

参考枚举:org.springframework.beans.factory.annotation.Autowire

有效的减少xml配置，全自动。例如手动配置<proeprty name="user" ref="user"/>，如果属性名称跟引用名称恰好相同，那么就可以把属性名称当作引用名称使用。当然缺点也很明显，重构变化会对这种方式造成影响。

#### Autowiring模式的不足之处：

1、依赖覆盖：手动的方式会覆盖掉自动绑定

2、不能绑定简单类型：原生类型（@Value）、String、Class

3、缺乏精确性：而且只有在运行时才会检查

4、多个bean的歧义性：NoUniqueBeanException，通过@primary来解套

## Setter方法注入

- 手动模式

  - XML 资源配置元信息
	- Java 注解配置元信息
	- API 配置元信息

- 自动模式

  - byName
  - byType

